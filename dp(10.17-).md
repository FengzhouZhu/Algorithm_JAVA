## 动态规划

### Example
给定一个三角形 triangle ，找出自顶向下的最小路径和。
每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

用f[i][j]表示从三角形顶部走到位置(i,j)的最小路径和。这里的位置(i,j)指的是三角形中第i行第j列（均从0开始编号）的位置。

由于每一步只能移动到下一行「相邻的节点」上，因此要想走到位置(i,j)，上一步就只能在位置(i−1,j−1) 或者位置(i−1,j)。我们在这两个位置中选择一个路径和较小的来进行转移，状态转移方程为：

f[i][j]=min (f[i-1][j-1], f[i-1][j])+c[i][j]

注意第i行有i+1个元素，它们对应的j的范围为[0,i]。当j=或j=i时，上述状态转移方程中有一些项是没有意义的。例如当j=0时，f[i−1][j−1] 没有意义，因此状态转移方程为：

f[i][0]=f[i−1][0]+c[i][0]

即当我们在第i行的最左侧时，我们只能从第i−1行的最左侧移动过来。当j=i 时，f[i−1][j] 没有意义，因此状态转移方程为：
f[i][i]=f[i−1][i−1]+c[i][i]

最终的答案即为f[n−1][0]到f[n−1][n−1]中的最小值，其中n是三角形的行数。

```
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        int[][] f = new int[n][n];
        f[0][0] = triangle.get(0).get(0);
        for(int i = 1;i < n;++i){
            f[i][0] = f[i-1][0] + triangle.get(i).get(0);
            for(int j = 1;j < i;++j){
                f[i][j] = Math.min(f[i-1][j-1],f[i-1][j])+triangle.get(i).get(j);
            }
            f[i][i] = f[i-1][i-1] + triangle.get(i).get(i);
        }
        int minTotal = f[n-1][0];
        for(int i = 1;i < n;++i){
            minTotal = Math.min(minTotal,f[n-1][i]);
        }
        return minTotal;
    }
}
```
